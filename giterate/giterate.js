// Generated by CoffeeScript 1.10.0
(function() {
  var Flow, Magic, Parser, Promise, args, child, colors, config, error, exec, fs, log, marker, min2ms, spawn;

  child = require("child_process");

  exec = child.exec;

  spawn = child.spawn;

  args = require("yargs").argv._;

  colors = require("colors");

  fs = require("fs");

  Promise = require("promise");

  config = {};

  log = function(output) {
    if (config.log) {
      return console.log(output.toString().green);
    }
  };

  error = function(error) {
    if (config.log) {
      return console.error(error.toString().red);
    }
  };

  marker = function() {
    return log("got here");
  };

  min2ms = function(min) {
    return min * 60 * 1000;
  };


  /* MAGIC */

  Magic = (function() {
    function Magic() {}

    Magic.spells = {
      cd: function(dir) {
        return "cd " + dir;
      },
      find: function(root) {
        return "find " + root + " -name .giterate -prune";
      },
      test: "ls -la",
      git: {
        add: "git add .",
        commit: function(message) {
          return "git commit -a -m \"" + message + "\"";
        },
        push: "git push -u --all",
        pull: "git pull --all",
        status: "git status"
      }
    };

    Magic.combine = function(array) {
      return array.join(" && ");
    };

    Magic.cast = function(spell, callback) {
      return exec(spell, callback);
    };

    Magic.perform = function(ritual, callback) {
      return this.cast(ritual, callback);
    };

    return Magic;

  })();


  /* PARSER */

  Parser = (function() {
    function Parser() {}

    Parser.commands = function(args) {
      if (args.length === 0) {
        return 'run';
      } else {
        if ((args[0] != null) && (args[1] != null)) {
          if (args[0] === 'summon' && args[1] === 'daemon') {
            return 'summon';
          }
          if (args[0] === 'dismiss' && args[1] === 'daemon') {
            return 'dismiss';
          }
        }
      }
    };

    Parser.paths = function(stdout) {
      var paths;
      paths = stdout.split("\n");
      return paths.map(function(path) {
        return path = path.slice(0, path.lastIndexOf("/"));
      });
    };

    return Parser;

  })();


  /* Flow */

  Flow = (function() {
    function Flow() {}

    Flow.init = function() {
      return new Promise(function(resolve, reject) {
        var command, data, err, error1;
        try {
          data = fs.readFileSync('giterate.json', 'utf8');
        } catch (error1) {
          err = error1;
          error("Cannot open giterate.json");
          reject();
        }
        config = JSON.parse(data);
        marker();
        command = Parser.commands(args);
        if (command === 'run') {
          Flow.runOnce();
        }
        if (command === 'summon') {
          Flow.start();
        }
        return resolve();
      });
    };

    Flow.runOnce = function() {
      return Magic.cast(Magic.spells.find(config.root), function(err, stdout, stderr) {
        var i, len, path, paths, results, ritual;
        paths = Parser.paths(stdout);
        results = [];
        for (i = 0, len = paths.length; i < len; i++) {
          path = paths[i];
          ritual = Magic.combine([Magic.spells.cd(path), Magic.spells.git.add, Magic.spells.git.commit(config.state), Magic.spells.git.pull, Magic.spells.git.push]);
          results.push(Magic.perform(ritual, function(err, stdout, stderr) {
            error(stderr);
            return log(stdout);
          }));
        }
        return results;
      });
    };

    Flow.start = function() {
      return log("fisk");
    };

    return Flow;

  })();

  Flow.init().then(function() {
    return Flow.run();
  }, function() {
    return error("Aborted...");
  });

}).call(this);
