readline = require "linebyline"
d = require "./dictionary"

dictionary = d.dictionary

class Modify

  @match: (object, property, value) ->
    typeof value is typeof object.properties[property]

  @error: (object, property, value) ->
    console.error "Error! Property '#{property}' of '#{object.name}' is #{type object.properties[property]}, not #{type value}"

  @set: (object, property, value) ->
    if @match object, property, value
      object.properties[property] = value
    else
      @error object, property, value

class Interface
  @present: (information) ->
    console.log information

class Parser
  @subclauses: (sentence) ->
    # TODO: Make more elegant!
    # Split by comma
    subclauses = sentence.split(',')
    lastIndex = subclauses.length - 1
    # Split by 'and'
    lastTwo = subclauses[lastIndex].split('and')
    subclauses = subclauses.slice(0, lastIndex)
    subclauses.push(lastTwo[0].trim())
    subclauses.push(lastTwo[1].trim())
    subclauses

  @main: (clauses) ->
    # Find verb in clause 1
    sentence = {main: {verb: null, noun: null}}
    for verb in dictionary.verbs
      pattern = new RegExp verb.phrase
      if clauses[0].match pattern
        sentence.main.verb = verb.function
      if verb.value?
        sentence.main.value = verb.value
      if verb.property?
        sentence.main.property = verb.property
    for noun in dictionary.nouns
      # Find with article
      pattern = new RegExp "the " + noun.name
      if clauses[0].match pattern
        sentence.main.noun = noun.object
        break
      # Find without article
      pattern = new RegExp noun.name
      if clauses[0].match pattern
        sentence.main.noun = noun.object
    sentence

  @sub: (clauses, sentence) ->
    sentence.sub = []

    # Remove main clause
    clauses = clauses.slice 1

    for clause in clauses

      subclause = {}

      # Find verb
      for verb in dictionary.verbs
        pattern = new RegExp verb.phrase
        if clause.match pattern
          subclause.verb = verb.function

      # Find property
      for key, value of sentence.main.noun.properties
        # Find with artcile
        pattern = new RegExp "the" + key
        if clause.match pattern
          subclause.property = key
        # Find without artcile
        else
          pattern = new RegExp key
          if clause.match pattern
            subclause.property = key
      if not subclause.property?
        subclause.property = "<NOT FOUND>"

      # Find value
      parts = clause.split " "
      subclause.value = parts[parts.length - 1]
      sentence.sub.push subclause

    sentence

  @construct: (sentence) ->
    main = sentence.main

    syntax = []

    row = main.verb + " " + main.noun.self + ", "  + main.property + ", " + main.value

    # Create first row
    syntax.push row

    for sub in sentence.sub
      row = sub.verb + " " + main.noun.self + ", "  + sub.property + ", " + sub.value
      syntax.push row

    syntax.join "\n"



lines = readline 'sub.pseudo'

Interface.present "\n### Generated by PseudoScript 0.1 ###\n"
# Add objects to output
for key, value of d.objects
  Interface.present key + ":"
  for k, v of value
    if typeof v is 'object'
      Interface.present "  " + k + ":"
      for k2, v2 of v
        Interface.present "    " + k2 + ": " + v2
    else
      Interface.present "  " + k + ": " + v

lines.on 'line', (line, number) ->
  clauses = Parser.subclauses(line)
  sentence = Parser.main(clauses)
  sentence = Parser.sub(clauses, sentence)
  Interface.present "\n# " + line
  Interface.present Parser.construct(sentence)

# TODO:
# Fix so that set isn't required in last subclause

