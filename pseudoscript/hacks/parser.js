// Generated by CoffeeScript 1.10.0
(function() {
  var Interface, Modify, Parser, d, dictionary, k, k2, key, lines, readline, ref, v, v2, value;

  readline = require("linebyline");

  d = require("./dictionary");

  dictionary = d.dictionary;

  Modify = (function() {
    function Modify() {}

    Modify.match = function(object, property, value) {
      return typeof value === typeof object.properties[property];
    };

    Modify.error = function(object, property, value) {
      return console.error("Error! Property '" + property + "' of '" + object.name + "' is " + (type(object.properties[property])) + ", not " + (type(value)));
    };

    Modify.set = function(object, property, value) {
      if (this.match(object, property, value)) {
        return object.properties[property] = value;
      } else {
        return this.error(object, property, value);
      }
    };

    return Modify;

  })();

  Interface = (function() {
    function Interface() {}

    Interface.present = function(information) {
      return console.log(information);
    };

    return Interface;

  })();

  Parser = (function() {
    function Parser() {}

    Parser.subclauses = function(sentence) {
      var lastIndex, lastTwo, subclauses;
      subclauses = sentence.split(',');
      lastIndex = subclauses.length - 1;
      lastTwo = subclauses[lastIndex].split('and');
      subclauses = subclauses.slice(0, lastIndex);
      subclauses.push(lastTwo[0].trim());
      subclauses.push(lastTwo[1].trim());
      return subclauses;
    };

    Parser.main = function(clauses) {
      var i, j, len, len1, noun, pattern, ref, ref1, sentence, verb;
      sentence = {
        main: {
          verb: null,
          noun: null
        }
      };
      ref = dictionary.verbs;
      for (i = 0, len = ref.length; i < len; i++) {
        verb = ref[i];
        pattern = new RegExp(verb.phrase);
        if (clauses[0].match(pattern)) {
          sentence.main.verb = verb["function"];
        }
        if (verb.value != null) {
          sentence.main.value = verb.value;
        }
        if (verb.property != null) {
          sentence.main.property = verb.property;
        }
      }
      ref1 = dictionary.nouns;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        noun = ref1[j];
        pattern = new RegExp("the " + noun.name);
        if (clauses[0].match(pattern)) {
          sentence.main.noun = noun.object;
          break;
        }
        pattern = new RegExp(noun.name);
        if (clauses[0].match(pattern)) {
          sentence.main.noun = noun.object;
        }
      }
      return sentence;
    };

    Parser.sub = function(clauses, sentence) {
      var clause, i, j, key, len, len1, parts, pattern, ref, ref1, subclause, value, verb;
      sentence.sub = [];
      clauses = clauses.slice(1);
      for (i = 0, len = clauses.length; i < len; i++) {
        clause = clauses[i];
        subclause = {};
        ref = dictionary.verbs;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          verb = ref[j];
          pattern = new RegExp(verb.phrase);
          if (clause.match(pattern)) {
            subclause.verb = verb["function"];
          }
        }
        ref1 = sentence.main.noun.properties;
        for (key in ref1) {
          value = ref1[key];
          pattern = new RegExp("the" + key);
          if (clause.match(pattern)) {
            subclause.property = key;
          } else {
            pattern = new RegExp(key);
            if (clause.match(pattern)) {
              subclause.property = key;
            }
          }
        }
        if (subclause.property == null) {
          subclause.property = "<NOT FOUND>";
        }
        parts = clause.split(" ");
        subclause.value = parts[parts.length - 1];
        sentence.sub.push(subclause);
      }
      return sentence;
    };

    Parser.construct = function(sentence) {
      var i, len, main, ref, row, sub, syntax;
      main = sentence.main;
      syntax = [];
      row = main.verb + " " + main.noun.self + ", " + main.property + ", " + main.value;
      syntax.push(row);
      ref = sentence.sub;
      for (i = 0, len = ref.length; i < len; i++) {
        sub = ref[i];
        row = sub.verb + " " + main.noun.self + ", " + sub.property + ", " + sub.value;
        syntax.push(row);
      }
      return syntax.join("\n");
    };

    return Parser;

  })();

  lines = readline('sub.pseudo');

  Interface.present("\n### Generated by PseudoScript 0.1 ###\n");

  ref = d.objects;
  for (key in ref) {
    value = ref[key];
    Interface.present(key + ":");
    for (k in value) {
      v = value[k];
      if (typeof v === 'object') {
        Interface.present("  " + k + ":");
        for (k2 in v) {
          v2 = v[k2];
          Interface.present("    " + k2 + ": " + v2);
        }
      } else {
        Interface.present("  " + k + ": " + v);
      }
    }
  }

  lines.on('line', function(line, number) {
    var clauses, sentence;
    clauses = Parser.subclauses(line);
    sentence = Parser.main(clauses);
    sentence = Parser.sub(clauses, sentence);
    Interface.present("\n# " + line);
    return Interface.present(Parser.construct(sentence));
  });

}).call(this);
